package com.listify.backend.model;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.listify.backend.model.enums.UserPermission;
import com.listify.backend.model.enums.UserStatus;
import jakarta.persistence.*;
import lombok.*;

/**
 * Represents a user of the application.
 * This entity stores essential user information, including credentials (username, email, password),
 * personal details (avatar, PayPal email), and their association with a {@link Group}.
 * It also defines the user's status and permission level within the system.
 * Lombok is used to generate standard getters, setters, and constructors.
 * The {@code equals()} and {@code hashCode()} methods are overridden to ensure
 * proper entity comparison based on the database identifier.
 *
 * @author Listify Team
 * @version 1.0
 * @see Group
 * @see UserStatus
 * @see UserPermission
 */

@Entity
@Table(name = "users")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class User {

    /**
     * The unique identifier for the user.
     * Automatically generated by the database.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * The user's display name.
     */
    private String username;

    /**
     * The user's email address. Must be unique across all users
     * and is typically used for login and identification.
     */
    @Column(unique = true)
    private String email;

    /**
     * The user's hashed password. This should never be stored in plain text.
     */
    private String password;

    /**
     * The user's PayPal email address, used for financial transactions or settlements.
     */
    @Column(name = "paypal_email")
    private String paypalEmail;

    /**
     * The group to which the user belongs.
     * The {@code @JsonIgnoreProperties} annotation is used to prevent circular serialization
     * (User -> Group -> List of Users) and to reduce the payload of the JSON response
     * by excluding large or unnecessary collections.
     */
    @ManyToOne
    @JoinColumn(name = "group_id")
    @JsonIgnoreProperties({"users", "shoppingLists", "debts"})
    private Group group;

    /**
     * The URL pointing to the user's avatar or profile picture.
     */
    @Column(name = "avatar_url")
    private String avatarUrl;

    /**
     * The current status of the user account (e.g., ACTIVE, PENDING, DEACTIVATED).
     * @see UserStatus
     */
    @Enumerated(EnumType.STRING)
    private UserStatus status;

    /**
     * The permission level of the user (e.g., USER, ADMIN).
     * @see UserPermission
     */
    @Enumerated(EnumType.STRING)
    private UserPermission permission;

    /**
     * Compares this User with another object for equality.
     * The comparison is based on the database identifier (ID). Two user instances are
     * considered equal if they are the same object or if they are both of type {@code User}
     * and have the same non-null ID. This is a common and robust approach for JPA entities.
     *
     * @param o The object to compare with.
     * @return {@code true} if the objects are equal, {@code false} otherwise.
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof User user)) return false;
        return id != null && id.equals(user.getId());
    }

    /**
     * Generates a hash code for the User object.
     * This implementation returns a constant hash code based on the class. It is a "safe"
     * implementation that is consistent with the {@code equals} method, especially for
     * transient (pre-persistence) entities where the ID might be null.
     * While not optimal for performance in hash-based collections, it prevents
     * {@code hashCode()} from changing after an entity is persisted and assigned an ID.
     *
     * @return A fixed hash code value for the User class.
     */
    @Override
    public int hashCode() {
        return getClass().hashCode();
    }
}

